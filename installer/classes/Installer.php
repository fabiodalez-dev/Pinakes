<?php
/**
 * Installer Class - Main Installation Logic
 */

class Installer {

    private const EXPECTED_TABLES = [
        'admin_notifications',
        'api_keys',
        'autori',
        'classificazione',
        'cms_pages',
        'contact_messages',
        'copie',
        'donazioni',
        'editori',
        'email_templates',
        'feedback',
        'generi',
        'home_content',
        'events',
        'languages',
        'libri',
        'libri_autori',
        'libri_donati',
        'libri_tag',
        'log_modifiche',
        'mensole',
        'plugin_data',
        'plugin_hooks',
        'plugin_logs',
        'plugin_settings',
        'plugins',
        'posizioni',
        'preferenze_notifica_utenti',
        'prenotazioni',
        'prestiti',
        'recensioni',
        'scaffali',
        'staff',
        'system_settings',
        'tag',
        'themes',
        'utenti',
        'wishlist',
        'z39_access_logs',
        'z39_rate_limits'
    ];

    private $baseDir;
    private $pdo;
    private $config = [];
    /**
     * @var array Warnings generated during trigger import
     */
    private $triggerWarnings = [];

    public function __construct($baseDir) {
        $this->baseDir = rtrim($baseDir, '/');
    }

    /**
     * Create .env file with database configuration
     */
    public function createEnvFile($host, $user, $password, $database, $port = 3306, $socket = '', $locale = 'it') {

        // Normalize locale:
        // - "it" or "it_IT" -> it_IT
        // - "en" or "en_US" -> en_US
        $normalizedLocale = strtolower((string)$locale);
        if ($normalizedLocale === 'en' || $normalizedLocale === 'en_us') {
            $normalizedLocale = 'en_US';
        } elseif ($normalizedLocale === 'it' || $normalizedLocale === 'it_it') {
            $normalizedLocale = 'it_IT';
        }

        // Fallback safety
        if (!in_array($normalizedLocale, ['it_IT', 'en_US'], true)) {
            $normalizedLocale = 'it_IT';
        }

        $envPath = $this->baseDir . '/.env';

        $envContent = "# Environment Configuration - Pinakes\n";
        $envContent .= "# Generated by installer on " . date('Y-m-d H:i:s') . "\n";
        $envContent .= "# IMPORTANT: Keep this file secure and never commit it to version control\n\n";

        $envContent .= "# Database Configuration\n";
        $envContent .= "DB_HOST={$host}\n";
        $envContent .= "DB_USER={$user}\n";
        $envContent .= "DB_PASS={$password}\n";
        $envContent .= "DB_NAME={$database}\n";
        $envContent .= "DB_PORT={$port}\n";
        $envContent .= "DB_SOCKET={$socket}\n\n";

        $envContent .= "# Application Environment\n";
        $envContent .= "# Set to 'production' for live environments, 'development' for local dev\n";
        $envContent .= "APP_ENV=production\n\n";

        $envContent .= "# Application Language\n";
        $envContent .= "# Default language for the entire application (e.g. it_IT, en_US)\n";
        $envContent .= "# Received: {$locale} | Normalized: {$normalizedLocale}\n";
        $envContent .= "APP_LOCALE={$normalizedLocale}\n\n";

        $envContent .= "# Debug Mode\n";
        $envContent .= "# MUST be false in production for security reasons\n";
        $envContent .= "APP_DEBUG=false\n\n";

        $envContent .= "# Encryption Key\n";
        $envContent .= "# Used to encrypt sensitive settings (e.g. plugin API keys). Regenerate if compromised.\n";
        $envContent .= "PLUGIN_ENCRYPTION_KEY=" . $this->generateEncryptionKey() . "\n\n";

        $envContent .= "# Session Security\n";
        $envContent .= "# Session lifetime in seconds (default: 3600 = 1 hour)\n";
        $envContent .= "SESSION_LIFETIME=3600\n\n";

        $envContent .= "# Display Errors\n";
        $envContent .= "# MUST be false in production (errors logged instead of displayed)\n";
        $envContent .= "DISPLAY_ERRORS=false\n\n";

        $envContent .= "# Force HTTPS\n";
        $envContent .= "# Set to 'true' only if your server supports HTTPS (requires valid SSL certificate)\n";
        $envContent .= "# Leave 'false' for local development or HTTP-only production servers\n";
        $envContent .= "FORCE_HTTPS=false\n";
        $envContent .= "\n# Canonical URL (auto-detected during installation)\n";
        $envContent .= "APP_CANONICAL_URL=" . $this->detectCanonicalUrl() . "\n";

        return file_put_contents($envPath, $envContent) !== false;
    }

    /**
     * Load database configuration from .env
     */
    public function loadEnvConfig() {
        $envPath = $this->baseDir . '/.env';

        if (!file_exists($envPath)) {
            throw new Exception(__("File .env non trovato"));
        }

        $lines = file($envPath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);

        foreach ($lines as $line) {
            if (strpos($line, '=') !== false && !str_starts_with(trim($line), '#')) {
                [$key, $value] = explode('=', $line, 2);
                $this->config[trim($key)] = trim($value, '"\'');
            }
        }

        return true;
    }

    /**
     * Get database connection
     */
    public function getDatabaseConnection() {
        if ($this->pdo) {
            return $this->pdo;
        }

        $host = $this->config['DB_HOST'] ?? 'localhost';
        $port = (int)($this->config['DB_PORT'] ?? 3306);
        $database = $this->config['DB_NAME'] ?? '';
        $username = $this->config['DB_USER'] ?? 'root';
        $password = $this->config['DB_PASS'] ?? '';
        $socket = $this->config['DB_SOCKET'] ?? '';

        // Build DSN
        $dsn = "mysql:";

        if (!empty($socket)) {
            $dsn .= "unix_socket={$socket};";
        } elseif ($host === 'localhost') {
            $socketPaths = [
                '/tmp/mysql.sock',
                '/var/run/mysqld/mysqld.sock',
                '/usr/local/var/mysql/mysql.sock',
                '/opt/homebrew/var/mysql/mysql.sock'
            ];

            $found = false;
            foreach ($socketPaths as $path) {
                if (file_exists($path)) {
                    $dsn .= "unix_socket={$path};";
                    $found = true;
                    break;
                }
            }

            if (!$found) {
                $dsn .= "host={$host};port={$port};";
            }
        } else {
            $dsn .= "host={$host};port={$port};";
        }

        $dsn .= "dbname={$database};charset=utf8mb4";

        $this->pdo = new PDO($dsn, $username, $password, [
            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
            PDO::MYSQL_ATTR_INIT_COMMAND => "SET NAMES utf8mb4 COLLATE utf8mb4_unicode_ci"
        ]);

        return $this->pdo;
    }

    /**
     * Import database schema using MySQL CLI or PDO fallback
     */
    public function importSchema() {
        // Use absolute path to avoid issues with chdir()
        $installerDir = dirname(__DIR__);
        $schemaFile = $installerDir . '/database/schema.sql';

        if (!file_exists($schemaFile)) {
            // Try to resolve the real path
            $realSchemaFile = realpath($installerDir . '/database/schema.sql');
            if ($realSchemaFile === false) {
                throw new Exception("File schema.sql non trovato. Cercato in: " . $schemaFile . " (installer dir: " . $installerDir . ")");
            }
            $schemaFile = $realSchemaFile;
        }

        // Try exec() method first (faster and more reliable)
        if (function_exists('exec')) {
            try {
                return $this->importSchemaViaExec($schemaFile);
            } catch (Exception $e) {
                // If exec() fails, fall back to PDO method
                error_log("exec() method failed, falling back to PDO: " . $e->getMessage());
            }
        }

        // Fallback to PDO method (works on all hosting, including those with exec() disabled)
        return $this->importSchemaViaPDO($schemaFile);
    }

    /**
     * Import initial data (classificazione, generi, email_templates)
     */
    public function importData() {
        $installerDir = dirname(__DIR__);

        // Get locale from session first (most reliable), fallback to .env
        $locale = $_SESSION['app_locale'] ?? ($this->config['APP_LOCALE'] ?? 'it');

        // Convert locale code to full form (supports it, it_IT, en, en_US)
        $localeMap = [
            'it' => 'it_IT',
            'it_it' => 'it_IT',
            'it_IT' => 'it_IT',
            'en' => 'en_US',
            'en_us' => 'en_US',
            'en_US' => 'en_US',
        ];
        $normalizedLocale = strtolower(str_replace('-', '_', $locale));
        $fullLocale = $localeMap[$normalizedLocale] ?? 'it_IT';

        // Try locale-specific data file first (data_it_IT.sql or data_en_US.sql)
        $dataFile = $installerDir . '/database/data_' . $fullLocale . '.sql';

        // If locale-specific file does not exist, do not fallback to generic data.sql
        // This enforces explicit language-specific seed files only.
        if (!file_exists($dataFile)) {
            throw new Exception(sprintf(__("File dati iniziali per la lingua selezionata non trovato: %s"), basename($dataFile)));
        }

        // Try exec() method first (faster and more reliable)
        if (function_exists('exec')) {
            try {
                return $this->importDataViaExec($dataFile);
            } catch (Exception $e) {
                error_log("exec() method failed for data import, falling back to PDO: " . $e->getMessage());
            }
        }

        // Fallback to PDO method
        return $this->importDataViaPDO($dataFile);
    }

    /**
     * Import schema using MySQL CLI (faster but requires exec())
     */
    private function importSchemaViaExec($schemaFile) {
        $host = $this->config['DB_HOST'] ?? 'localhost';
        $port = (int)($this->config['DB_PORT'] ?? 3306);
        $database = $this->config['DB_NAME'] ?? '';
        $username = $this->config['DB_USER'] ?? 'root';
        $password = $this->config['DB_PASS'] ?? '';

        // Build mysql command
        $cmd = 'mysql';
        $cmd .= ' -h ' . escapeshellarg($host);
        $cmd .= ' -P ' . (int)$port;
        $cmd .= ' -u ' . escapeshellarg($username);
        if (!empty($password)) {
            $cmd .= ' -p' . escapeshellarg($password);
        }
        $cmd .= ' --default-character-set=utf8mb4'; // Force UTF-8 to prevent encoding corruption (ðŸ“š â†’ Ã°Å¸"Å¡, Ãˆ â†’ ÃƒË†)
        $cmd .= ' ' . escapeshellarg($database);
        $cmd .= ' < ' . escapeshellarg($schemaFile);

        // Execute mysql command
        $output = [];
        $exitCode = 0;
        exec($cmd . ' 2>&1', $output, $exitCode);

        if ($exitCode !== 0) {
            $errorMsg = implode("\n", $output);
            throw new Exception("Errore importazione schema (exit code: $exitCode): " . $errorMsg);
        }

        return $this->verifySchemaImport();
    }

    /**
     * Import schema using PDO (works on all hosting)
     */
    private function importSchemaViaPDO($schemaFile) {
        // Read schema file
        $sql = file_get_contents($schemaFile);
        if ($sql === false) {
            throw new Exception("Impossibile leggere il file schema.sql");
        }

        // Get PDO connection
        $pdo = $this->getDatabaseConnection();

        // Split SQL into statements
        // Remove comments and handle MySQL conditional comments
        $sql = preg_replace('/--.*$/m', '', $sql); // Remove single-line comments
        $sql = preg_replace('/\/\*(?!\!).*?\*\//s', '', $sql); // Remove normal multi-line comments (not /*!... */)
        // Unwrap MySQL conditional comments: /*!40101 SET ... */ becomes just: SET ...
        $sql = preg_replace('/\/\*!\d+\s*(.*?)\s*\*\//s', '$1', $sql);

        // Split by semicolon, but handle DELIMITER statements
        $statements = [];
        $buffer = '';
        $inDelimiter = false;

        foreach (explode("\n", $sql) as $line) {
            $trimmed = trim($line);

            // Check for DELIMITER command
            if (preg_match('/^DELIMITER\s+(.+)$/i', $trimmed, $matches)) {
                $inDelimiter = true;
                continue;
            }

            $buffer .= $line . "\n";

            // Check if statement ends
            if ($inDelimiter) {
                // Looking for $$ delimiter
                if (strpos($trimmed, '$$') !== false) {
                    $statements[] = trim($buffer);
                    $buffer = '';
                    $inDelimiter = false;
                }
            } else {
                // Standard semicolon delimiter
                if (substr($trimmed, -1) === ';') {
                    $statements[] = trim($buffer);
                    $buffer = '';
                }
            }
        }

        // Add remaining buffer if any
        if (!empty(trim($buffer))) {
            $statements[] = trim($buffer);
        }

        // Execute each statement
        $executedCount = 0;
        $errors = [];

        foreach ($statements as $statement) {
            $statement = trim($statement);

            // Skip empty statements
            if (empty($statement)) {
                continue;
            }

            // Skip DELIMITER statements
            if (preg_match('/^DELIMITER/i', $statement)) {
                continue;
            }

            try {
                $pdo->exec($statement);
                $executedCount++;
            } catch (PDOException $e) {
                // Some statements might fail (like IF NOT EXISTS checks)
                // Only collect real errors
                if (strpos($e->getMessage(), 'already exists') === false) {
                    $errors[] = "Statement error: " . $e->getMessage();
                }
            }
        }

        if (!empty($errors)) {
            error_log("Schema import warnings: " . implode("\n", $errors));
            // If too many errors, throw exception with first few errors for debugging
            if (count($errors) > 10) {
                $firstErrors = array_slice($errors, 0, 5);
                throw new Exception(sprintf(__("Troppi errori durante l'import dello schema (%d errori). Primi errori:\n%s"), count($errors), implode("\n", $firstErrors)));
            }
        }

        return $this->verifySchemaImport();
    }

    /**
     * Import data using MySQL CLI (faster but requires exec())
     */
    private function importDataViaExec($dataFile) {
        $host = $this->config['DB_HOST'] ?? 'localhost';
        $port = (int)($this->config['DB_PORT'] ?? 3306);
        $database = $this->config['DB_NAME'] ?? '';
        $username = $this->config['DB_USER'] ?? 'root';
        $password = $this->config['DB_PASS'] ?? '';

        // Build mysql command
        $cmd = 'mysql';
        $cmd .= ' -h ' . escapeshellarg($host);
        $cmd .= ' -P ' . (int)$port;
        $cmd .= ' -u ' . escapeshellarg($username);
        if (!empty($password)) {
            $cmd .= ' -p' . escapeshellarg($password);
        }
        $cmd .= ' --default-character-set=utf8mb4'; // Force UTF-8 to prevent encoding corruption (ðŸ“š â†’ Ã°Å¸"Å¡, Ãˆ â†’ ÃƒË†)
        $cmd .= ' ' . escapeshellarg($database);
        $cmd .= ' < ' . escapeshellarg($dataFile);

        // Execute mysql command
        $output = [];
        $exitCode = 0;
        exec($cmd . ' 2>&1', $output, $exitCode);

        if ($exitCode !== 0) {
            $errorMsg = implode("\n", $output);
            throw new Exception("Errore importazione dati (exit code: $exitCode): " . $errorMsg);
        }

        return true;
    }

    /**
     * Import data using PDO (works on all hosting)
     */
    private function importDataViaPDO($dataFile) {
        // Read data file
        $sql = file_get_contents($dataFile);
        if ($sql === false) {
            throw new Exception("Impossibile leggere il file data.sql");
        }

        // Get PDO connection
        $pdo = $this->getDatabaseConnection();

        // Split SQL into statements (simpler than schema - just INSERT statements)
        $statements = array_filter(explode(";\n", $sql), function($stmt) {
            return !empty(trim($stmt));
        });

        $executedCount = 0;
        $errors = [];

        foreach ($statements as $statement) {
            $statement = trim($statement);

            if (empty($statement)) {
                continue;
            }

            try {
                $pdo->exec($statement);
                $executedCount++;
            } catch (PDOException $e) {
                // Collect errors but continue (some INSERTs might fail due to duplicates)
                if (strpos($e->getMessage(), 'Duplicate entry') === false) {
                    $errors[] = "Data import error: " . $e->getMessage();
                }
            }
        }

        if (!empty($errors) && count($errors) > 10) {
            $firstErrors = array_slice($errors, 0, 5);
            throw new Exception(sprintf(__("Troppi errori durante l'import dei dati (%d errori). Primi errori:\n%s"), count($errors), implode("\n", $firstErrors)));
        }

        return true;
    }

    /**
     * Verify schema was imported correctly
     */
    private function verifySchemaImport() {
        // IMPORTANT: Close old PDO connection and reset it
        // This ensures new connections see the newly created tables
        $this->pdo = null;

        // Verify that tables were created with fresh connection
        try {
            $pdo = $this->getDatabaseConnection();
            $stmt = $pdo->query("SHOW TABLES");
            $tables = $stmt->fetchAll(PDO::FETCH_COLUMN);

            if (!is_array($tables) || empty($tables)) {
                throw new Exception("Schema non importato correttamente. Nessuna tabella trovata.");
            }

            $actual = array_map('strtolower', $tables);
            sort($actual);

            $expected = self::EXPECTED_TABLES;
            sort($expected);

            $missing = array_diff($expected, $actual);
            if (!empty($missing)) {
                throw new Exception(sprintf(__("Schema non importato correttamente. Tabelle mancanti: %s"), implode(', ', $missing)));
            }

            if (count($actual) < count($expected)) {
                throw new Exception(sprintf(__("Schema incompleto: trovate %d tabelle su %d attese."), count($actual), count($expected)));
            }
        } catch (PDOException $e) {
            throw new Exception(sprintf(__("Errore verifica tabelle: %s"), $e->getMessage()));
        }

        return true;
    }

    /**
     * Import database triggers
     */
    public function importTriggers() {
        $this->triggerWarnings = [];
        // Use absolute path to avoid issues with chdir()
        $installerDir = dirname(__DIR__);
        $triggersFile = $installerDir . '/database/triggers.sql';

        if (!file_exists($triggersFile)) {
            $this->triggerWarnings[] = "File triggers.sql non trovato â€” nessun trigger installato.";
            return true;
        }

        $sql = file_get_contents($triggersFile);

        if (!is_string($sql) || trim($sql) === '') {
            $this->triggerWarnings[] = "File triggers.sql vuoto â€” nessun trigger installato.";
            return true;
        }

        $pdo = $this->getDatabaseConnection();

        // Clean up DEFINER clauses and remove DELIMITER statements
        $sql = preg_replace('/CREATE\s+DEFINER=`[^`]+`@`[^`]+`\s+TRIGGER/i', 'CREATE TRIGGER', $sql);
        $sql = preg_replace('/DELIMITER\s+\S+/i', '', $sql);

        // Split the file into statements using '$$' as the delimiter
        $statements = explode('$$', $sql);

        $executedTriggers = 0;
        foreach ($statements as $statement) {
            $statement = trim($statement);
            if (empty($statement)) {
                continue;
            }

            try {
                $pdo->exec($statement);
                if (stripos($statement, 'CREATE TRIGGER') === 0) {
                    $executedTriggers++;
                }
            } catch (PDOException $e) {
                $message = $e->getMessage();
                $this->triggerWarnings[] = "Impossibile eseguire uno statement del trigger: {$message}";
                // Continue to the next statement
            }
        }

        if ($executedTriggers === 0 && empty($this->triggerWarnings)) {
            $this->triggerWarnings[] = "Nessun trigger valido trovato nel file triggers.sql.";
        }

        return true;
    }

    /**
     * Retrieve warnings generated during trigger import
     *
     * @return string[]
     */
    public function getTriggerWarnings(): array
    {
        return $this->triggerWarnings;
    }

    /**
     * Import optimization indexes from indexes_optimization.sql
     * These indexes improve query performance but are not critical for basic functionality
     *
     * @return bool
     */
    public function importOptimizationIndexes(): bool
    {
        $installerDir = dirname(__DIR__);
        $indexesFile = $installerDir . '/database/indexes_optimization.sql';

        if (!file_exists($indexesFile)) {
            // File opzionale - non Ã¨ un errore se manca
            return true;
        }

        $sql = file_get_contents($indexesFile);
        if (!is_string($sql) || trim($sql) === '') {
            return true;
        }

        $pdo = $this->getDatabaseConnection();

        // Rimuovi commenti e dividi in statement
        $lines = explode("\n", $sql);
        $statements = [];
        $currentStatement = '';

        foreach ($lines as $line) {
            $line = trim($line);
            // Salta commenti e linee vuote
            if (empty($line) || strpos($line, '--') === 0 || strpos($line, '#') === 0) {
                continue;
            }
            $currentStatement .= ' ' . $line;
            if (substr($line, -1) === ';') {
                $statements[] = trim($currentStatement);
                $currentStatement = '';
            }
        }

        foreach ($statements as $statement) {
            if (empty($statement)) {
                continue;
            }
            try {
                $pdo->exec($statement);
            } catch (\PDOException $e) {
                // Ignora errori su indici duplicati (giÃ  esistenti)
                // Error code 1061 = Duplicate key name
                if (strpos($e->getMessage(), '1061') === false &&
                    strpos($e->getMessage(), 'Duplicate') === false) {
                    // Log altri errori ma continua
                    error_log("Index optimization warning: " . $e->getMessage());
                }
            }
        }

        return true;
    }

    /**
     * Verify database installation
     */
    public function verifyInstallation() {
        $pdo = $this->getDatabaseConnection();

        // Count tables
        $stmt = $pdo->query("SHOW TABLES");
        $tables = $stmt->fetchAll(PDO::FETCH_COLUMN);

        $actualTables = array_map('strtolower', $tables);
        sort($actualTables);
        $expectedTables = self::EXPECTED_TABLES;
        sort($expectedTables);

        $missing = array_diff($expectedTables, $actualTables);
        if (!empty($missing)) {
            throw new Exception(sprintf(__("Installazione database non completa. Tabelle mancanti: %s"), implode(', ', $missing)));
        }

        if (count($actualTables) !== count($expectedTables)) {
            throw new Exception(sprintf(__("Installazione database non completa. Trovate %d tabelle, attese %d"), count($actualTables), count($expectedTables)));
        }

        // Check essential data
        $stmt = $pdo->query("SELECT COUNT(*) as count FROM classificazione");
        $result = $stmt->fetch();
        if ($result['count'] == 0) {
            throw new Exception(__("Dati di classificazione mancanti"));
        }

        $stmt = $pdo->query("SELECT COUNT(*) as count FROM generi");
        $result = $stmt->fetch();
        if ($result['count'] == 0) {
            throw new Exception(__("Dati generi mancanti"));
        }


        return true;
    }

    /**
     * Create admin user
     */
    public function createAdminUser($nome, $cognome, $email, $password) {

        $pdo = $this->getDatabaseConnection();

        // Decode HTML entities that might have been added during sanitization
        $nome = html_entity_decode($nome, ENT_QUOTES, 'UTF-8');
        $cognome = html_entity_decode($cognome, ENT_QUOTES, 'UTF-8');

        // Generate unique codice_tessera
        $codiceTessera = 'ADMIN-' . date('Ymd') . '-' . str_pad((string)rand(1, 999), 3, '0', STR_PAD_LEFT);

        // Hash password
        $passwordHash = password_hash($password, PASSWORD_BCRYPT);

        // Insert admin user
        $query = "
            INSERT INTO utenti (
                nome, cognome, email, password, codice_tessera,
                tipo_utente, stato, email_verificata,
                data_scadenza_tessera, created_at, updated_at
            ) VALUES (
                :nome, :cognome, :email, :password, :codice_tessera,
                'admin', 'attivo', 1,
                DATE_ADD(NOW(), INTERVAL 10 YEAR), NOW(), NOW()
            )
        ";

        try {
            $stmt = $pdo->prepare($query);

            $stmt->execute([
                'nome' => $nome,
                'cognome' => $cognome,
                'email' => $email,
                'password' => $passwordHash,
                'codice_tessera' => $codiceTessera
            ]);

            $userId = $pdo->lastInsertId();

            return [
                'id' => $userId,
                'codice_tessera' => $codiceTessera
            ];
        } catch (PDOException $e) {
            throw $e;
        }
    }

    /**
     * Save application settings to database ONLY (no more JSON file)
     */
    public function saveSetting($category, $key, $value) {
        // Try to load env if not already loaded
        if (empty($this->config)) {
            try {
                $this->loadEnvConfig();
            } catch (Exception $e) {
                throw new Exception(__("Impossibile caricare configurazione database") . ": " . $e->getMessage());
            }
        }

        // Ensure database connection is available
        try {
            $pdo = $this->getDatabaseConnection();
        } catch (Exception $e) {
            throw new Exception(__("Errore connessione database") . ": " . $e->getMessage());
        }

        if (!$pdo) {
            throw new Exception(__("Connessione database non disponibile"));
        }

        $stmt = $pdo->prepare("
            INSERT INTO system_settings (category, setting_key, setting_value, updated_at)
            VALUES (?, ?, ?, NOW())
            ON DUPLICATE KEY UPDATE setting_value = ?, updated_at = NOW()
        ");

        $valueStr = is_bool($value) ? ($value ? '1' : '0') : (string)$value;
        $stmt->execute([$category, $key, $valueStr, $valueStr]);

        return true;
    }

    /**
     * Alias for saveSetting() for backward compatibility
     */
    public function saveSettingToDatabase($category, $key, $value) {
        return $this->saveSetting($category, $key, $value);
    }

    /**
     * Upload and save logo
     */
    public function uploadLogo($file) {
        $uploadDir = $this->baseDir . '/public/assets';

        if (!is_dir($uploadDir)) {
            mkdir($uploadDir, 0755, true);
        }

        // Generate unique filename
        $extension = pathinfo($file['name'], PATHINFO_EXTENSION);
        $filename = 'logo_' . uniqid() . '.' . $extension;
        $destination = $uploadDir . '/' . $filename;

        if (!move_uploaded_file($file['tmp_name'], $destination)) {
            throw new Exception("Impossibile salvare il logo");
        }

        return '/assets/' . $filename;
    }

    /**
     * Create default .htaccess if missing
     */
    public function createHtaccess() {
        $htaccessPath = $this->baseDir . '/.htaccess';

        if (file_exists($htaccessPath)) {
            return true; // Already exists
        }

        $htaccessContent = <<<'HTACCESS'
<IfModule mod_rewrite.c>
    RewriteEngine On
    RewriteBase /

    # Redirect all requests to index.php
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteRule ^(.*)$ index.php [QSA,L]
</IfModule>

# Disable directory browsing
Options -Indexes

# Protect sensitive files
<FilesMatch "^\.">
    Order allow,deny
    Deny from all
</FilesMatch>

<FilesMatch "^(composer\.(json|lock)|package(-lock)?\.json|\.env.*|.*\.md)$">
    Order allow,deny
    Deny from all
</FilesMatch>
HTACCESS;

        return file_put_contents($htaccessPath, $htaccessContent) !== false;
    }

    /**
     * Create installation lock file
     */
    public function createLockFile() {
        $lockFile = dirname(dirname(__DIR__)) . '/.installed';
        $lockContent = "Installed on: " . date('Y-m-d H:i:s') . "\n";
        $lockContent .= "Do not delete this file. It prevents re-installation.\n";

        return file_put_contents($lockFile, $lockContent) !== false;
    }

    /**
     * Check if installer is locked (already installed)
     */
    public function isInstalled() {
        return file_exists(dirname(dirname(__DIR__)) . '/.installed');
    }

    /**
     * Populate default system settings
     */
    public function populateDefaultSettings() {
        $defaults = [
            // Registration
            ['registration', 'require_admin_approval', '1'],

            // Contacts (empty defaults)
            ['contacts', 'contact_email', ''],
            ['contacts', 'contact_phone', ''],
            ['contacts', 'notification_email', ''],

            // Privacy
            ['privacy', 'cookie_banner_enabled', '0'],
        ];

        $locale = $this->getInstallerLocale();
        $localized = $this->getLocaleDefaultTexts($locale);

        foreach ($localized['app'] ?? [] as $key => $value) {
            $defaults[] = ['app', $key, $value];
        }

        foreach ($localized['contacts'] ?? [] as $key => $value) {
            $defaults[] = ['contacts', $key, $value];
        }

        foreach ($localized['privacy'] ?? [] as $key => $value) {
            $defaults[] = ['privacy', $key, $value];
        }

        foreach ($localized['cookie_banner'] ?? [] as $key => $value) {
            $defaults[] = ['cookie_banner', $key, $value];
        }

        foreach ($defaults as [$category, $key, $value]) {
            try {
                $this->saveSetting($category, $key, $value);
            } catch (Exception $e) {
                // Ignore if already exists
            }
        }

        // Persist selected locale for the application
        $this->saveSetting('app', 'locale', $locale);
        $this->setDefaultLanguage($locale);

        return true;
    }

    /**
     * Detect canonical URL of the current installation request.
     */
    private function detectCanonicalUrl(): string
    {
        $scheme = 'http';

        if (!empty($_SERVER['HTTP_X_FORWARDED_PROTO'])) {
            $forwardedProto = explode(',', (string)$_SERVER['HTTP_X_FORWARDED_PROTO'])[0];
            $scheme = strtolower($forwardedProto) === 'https' ? 'https' : 'http';
        } elseif (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off') {
            $scheme = 'https';
        } elseif (!empty($_SERVER['REQUEST_SCHEME'])) {
            $scheme = strtolower((string)$_SERVER['REQUEST_SCHEME']) === 'https' ? 'https' : 'http';
        } elseif (isset($_SERVER['SERVER_PORT']) && (int)$_SERVER['SERVER_PORT'] === 443) {
            $scheme = 'https';
        }

        $host = 'localhost';
        if (!empty($_SERVER['HTTP_X_FORWARDED_HOST'])) {
            $host = explode(',', (string)$_SERVER['HTTP_X_FORWARDED_HOST'])[0];
        } elseif (!empty($_SERVER['HTTP_HOST'])) {
            $host = (string)$_SERVER['HTTP_HOST'];
        } elseif (!empty($_SERVER['SERVER_NAME'])) {
            $host = (string)$_SERVER['SERVER_NAME'];
        }

        $port = null;
        if (str_contains($host, ':')) {
            [$hostOnly, $portPart] = explode(':', $host, 2);
            $host = $hostOnly;
            $port = is_numeric($portPart) ? (int)$portPart : null;
        } elseif (!empty($_SERVER['HTTP_X_FORWARDED_PORT'])) {
            $port = (int)$_SERVER['HTTP_X_FORWARDED_PORT'];
        } elseif (isset($_SERVER['SERVER_PORT']) && is_numeric((string)$_SERVER['SERVER_PORT'])) {
            $port = (int)$_SERVER['SERVER_PORT'];
        }

        $base = $scheme . '://' . $host;
        $defaultPorts = ['http' => 80, 'https' => 443];
        if ($port !== null && ($defaultPorts[$scheme] ?? null) !== $port) {
            $base .= ':' . $port;
        }

        return rtrim($base, '/');
    }

    private function generateEncryptionKey(): string
    {
        try {
            $bytes = random_bytes(32);
            return 'base64:' . base64_encode($bytes);
        } catch (\Throwable $e) {
            return 'base64:' . base64_encode(hash('sha256', uniqid((string)mt_rand(), true), true));
        }
    }

    /**
     * Update a variable in the .env file
     * @param string $key Variable name (e.g., 'APP_CANONICAL_URL')
     * @param string $value New value
     * @return bool Success status
     */
    public function updateEnvVariable(string $key, string $value): bool
    {
        $envPath = $this->baseDir . '/.env';

        if (!file_exists($envPath)) {
            return false;
        }

        $envContent = file_get_contents($envPath);
        if ($envContent === false) {
            return false;
        }

        // Escape special regex characters in key
        $escapedKey = preg_quote($key, '/');

        // Pattern to match the key with any value (handles empty values too)
        $pattern = '/^' . $escapedKey . '=.*$/m';

        // New line content
        $replacement = $key . '=' . $value;

        // Replace the line
        if (preg_match($pattern, $envContent)) {
            $newContent = preg_replace($pattern, $replacement, $envContent);
        } else {
            // If key doesn't exist, append it
            $newContent = rtrim($envContent) . "\n" . $replacement . "\n";
        }

        return file_put_contents($envPath, $newContent) !== false;
    }

    private function getInstallerLocale(): string
    {
        $locale = $this->config['APP_LOCALE'] ?? 'it_IT';
        $locale = str_replace('-', '_', strtolower($locale));
        if ($locale === 'en' || $locale === 'en_us') {
            return 'en_US';
        }
        if ($locale === 'it' || $locale === 'it_it') {
            return 'it_IT';
        }
        return 'it_IT';
    }

    private function getLocaleDefaultTexts(string $locale): array
    {
        static $texts = null;

        if ($texts === null) {
            $path = $this->baseDir . '/config/default_texts.php';
            if (is_file($path)) {
                $texts = require $path;
            } else {
                $texts = [];
            }
        }

        $fallback = $texts['it_IT'] ?? [];
        if ($locale === 'it_IT' || !isset($texts[$locale])) {
            return $fallback;
        }

        return $this->mergeLocaleDefaults($fallback, $texts[$locale]);
    }

    private function mergeLocaleDefaults(array $base, array $override): array
    {
        foreach ($override as $key => $value) {
            if (is_array($value) && isset($base[$key]) && is_array($base[$key])) {
                $base[$key] = $this->mergeLocaleDefaults($base[$key], $value);
            } else {
                $base[$key] = $value;
            }
        }

        return $base;
    }

    private function setDefaultLanguage(string $locale): void
    {
        $pdo = $this->getDatabaseConnection();

        $pdo->exec("UPDATE languages SET is_default = 0");

        $stmt = $pdo->prepare("UPDATE languages SET is_default = 1 WHERE code = :code LIMIT 1");
        $stmt->execute(['code' => $locale]);
    }

    /**
     * Install Open Library plugin automatically during installation
     */
    public function installOpenLibraryPlugin() {
        $pluginSourceDir = $this->baseDir . '/storage/plugins/open-library';
        $pluginDestDir = $this->baseDir . '/storage/plugins';

        // Ensure plugins directory exists
        if (!is_dir($pluginDestDir)) {
            mkdir($pluginDestDir, 0755, true);
        }

        // Plugin should already be in storage/plugins/open-library from the repository
        if (!is_dir($pluginSourceDir)) {
            throw new Exception("Open Library plugin not found in storage/plugins/open-library");
        }

        // Get database connection
        $pdo = $this->getDatabaseConnection();

        // Insert plugin record only if not already installed
        $stmt = $pdo->prepare("SELECT id FROM plugins WHERE name = 'open-library' LIMIT 1");
        $stmt->execute();
        $pluginId = (int)$stmt->fetchColumn();

        if (!$pluginId) {
            $stmt = $pdo->prepare("
                INSERT INTO plugins (
                    name, display_name, description, version, author, author_url, plugin_url,
                    is_active, path, main_file, requires_php, requires_app, metadata, installed_at
                ) VALUES (
                    'open-library',
                    'Open Library Scraper',
                    'Integrates Open Library and Google Books APIs for comprehensive book metadata scraping. Supports ISBN lookup with multi-source fallback and encrypted API key storage.',
                    '1.0.0',
                    'Fabio Dal Maso',
                    '',
                    '',
                    1,
                    'open-library',
                    'wrapper.php',
                    '8.1',
                    '1.0.0',
                    '{}',
                    NOW()
                )
            ");

            $stmt->execute();
            $pluginId = (int)$pdo->lastInsertId();
        }

        if (!$pluginId) {
            throw new Exception(__("Impossibile determinare l'ID del plugin Open Library."));
        }

        // Register plugin hooks (avoid duplicates)
        $existingHooksStmt = $pdo->prepare("SELECT hook_name, callback_method FROM plugin_hooks WHERE plugin_id = ?");
        $existingHooksStmt->execute([$pluginId]);
        $existingHooks = $existingHooksStmt->fetchAll(PDO::FETCH_ASSOC);

        $existingMap = [];
        foreach ($existingHooks as $hook) {
            $existingMap[$hook['hook_name'] . '|' . $hook['callback_method']] = true;
        }

        $hooks = [
            ['scrape.sources', 'addOpenLibrarySource', 5],
            ['scrape.fetch.custom', 'fetchFromOpenLibrary', 5],
            ['scrape.data.modify', 'enrichWithOpenLibraryData', 10],
        ];

        foreach ($hooks as [$hookName, $callbackMethod, $priority]) {
            $key = $hookName . '|' . $callbackMethod;
            if (isset($existingMap[$key])) {
                continue;
            }

            $stmt = $pdo->prepare("
                INSERT INTO plugin_hooks (plugin_id, hook_name, callback_class, callback_method, priority, is_active, created_at)
                VALUES (?, ?, 'OpenLibraryPlugin', ?, ?, 1, NOW())
            ");

            $stmt->execute([$pluginId, $hookName, $callbackMethod, $priority]);
        }

        return $pluginId;
    }

    /**
     * Register and activate default plugins
     * Plugins: open-library, z39-server, api-book-scraper, digital-library
     * Excluded: scraping-pro (commercial/proprietary)
     */
    public function installPluginsFromZip() {
        $pdo = $this->getDatabaseConnection();
        $results = [];

        // Helper to ensure hooks exist
        $ensureHooks = function(int $pluginId, array $hooks, string $callbackClass) use ($pdo) {
            $existing = $pdo->prepare("SELECT hook_name, callback_method FROM plugin_hooks WHERE plugin_id = ?");
            $existing->execute([$pluginId]);
            $existingMap = [];
            foreach ($existing->fetchAll(PDO::FETCH_ASSOC) as $row) {
                $existingMap[$row['hook_name'] . '|' . $row['callback_method']] = true;
            }

            foreach ($hooks as $hook) {
                $hookName = $hook['name'];
                $callbackMethod = $hook['callback_method'] ?? ('handle' . ucfirst(str_replace('.', '', $hookName)));
                $priority = $hook['priority'] ?? 10;
                $key = $hookName . '|' . $callbackMethod;
                if (isset($existingMap[$key])) {
                    continue;
                }

                $stmt = $pdo->prepare("
                    INSERT INTO plugin_hooks (plugin_id, hook_name, callback_class, callback_method, priority, is_active, created_at)
                    VALUES (?, ?, ?, ?, ?, 1, NOW())
                ");
                $stmt->execute([$pluginId, $hookName, $callbackClass, $callbackMethod, $priority]);
            }
        };

        // Generic plugin installer
        $installPlugin = function(string $pluginName, array $additionalHooks = []) use ($pdo, $ensureHooks, &$results) {
            try {
                $pluginDir = $this->baseDir . '/storage/plugins/' . $pluginName;

                if (!is_dir($pluginDir)) {
                    $results[] = ['name' => $pluginName, 'status' => 'error', 'message' => 'Directory not found'];
                    return;
                }

                $pluginJsonPath = $pluginDir . '/plugin.json';
                if (!file_exists($pluginJsonPath)) {
                    $results[] = ['name' => $pluginName, 'status' => 'error', 'message' => 'plugin.json not found'];
                    return;
                }

                $pluginJson = json_decode(file_get_contents($pluginJsonPath), true);
                if (!$pluginJson) {
                    $results[] = ['name' => $pluginName, 'status' => 'error', 'message' => 'Invalid plugin.json'];
                    return;
                }

                $stmt = $pdo->prepare("SELECT id FROM plugins WHERE name = :name LIMIT 1");
                $stmt->execute(['name' => $pluginJson['name']]);
                $pluginId = (int)$stmt->fetchColumn();

                if (!$pluginId) {
                    $insertStmt = $pdo->prepare("
                        INSERT INTO plugins (name, display_name, description, version, author, author_url, plugin_url,
                            is_active, path, main_file, requires_php, requires_app, metadata, installed_at)
                        VALUES (:name, :display_name, :description, :version, :author, :author_url, :plugin_url,
                            1, :path, :main_file, :requires_php, :requires_app, :metadata, NOW())
                    ");

                    $insertStmt->execute([
                        'name' => $pluginJson['name'],
                        'display_name' => $pluginJson['display_name'],
                        'description' => $pluginJson['description'],
                        'version' => $pluginJson['version'],
                        'author' => $pluginJson['author'] ?? '',
                        'author_url' => $pluginJson['author_url'] ?? '',
                        'plugin_url' => $pluginJson['plugin_url'] ?? '',
                        'path' => $pluginName,
                        'main_file' => $pluginJson['main_file'],
                        'requires_php' => $pluginJson['requires_php'] ?? '8.0',
                        'requires_app' => $pluginJson['requires_app'] ?? '1.0',
                        'metadata' => json_encode($pluginJson['metadata'] ?? [])
                    ]);

                    $pluginId = (int)$pdo->lastInsertId();
                }

                // Register hooks from plugin.json
                $hooks = $pluginJson['metadata']['hooks'] ?? [];
                // Merge with additional hooks
                $hooks = array_merge($hooks, $additionalHooks);

                // Determine callback class from plugin name (CamelCase convention)
                $callbackClass = str_replace(' ', '', ucwords(str_replace('-', ' ', $pluginName))) . 'Plugin';

                if (!empty($hooks)) {
                    $ensureHooks($pluginId, $hooks, $callbackClass);
                }

                $results[] = ['name' => $pluginName, 'status' => 'installed_and_activated', 'plugin_id' => $pluginId];

            } catch (Exception $e) {
                $results[] = ['name' => $pluginName, 'status' => 'error', 'message' => $e->getMessage()];
            }
        };

        // Install all default plugins (excluding scraping-pro)
        $installPlugin('open-library');
        $installPlugin('z39-server', [
            ['name' => 'app.routes.register', 'callback_method' => 'registerRoutes', 'priority' => 10]
        ]);
        $installPlugin('api-book-scraper');
        $installPlugin('digital-library', [
            ['name' => 'app.routes.register', 'callback_method' => 'registerRoutes', 'priority' => 10]
        ]);

        return $results;
    }

    /**
     * Delete installer directory for security
     */
    public function deleteInstaller() {
        $installerDir = dirname(__DIR__);
        return $this->recursiveDelete($installerDir);
    }

    /**
     * Recursively delete directory
     */
    private function recursiveDelete($dir) {
        if (!is_dir($dir)) {
            return false;
        }

        $files = array_diff(scandir($dir), ['.', '..']);

        foreach ($files as $file) {
            $path = $dir . '/' . $file;
            is_dir($path) ? $this->recursiveDelete($path) : unlink($path);
        }

        return rmdir($dir);
    }
}
